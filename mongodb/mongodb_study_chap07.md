# 7. 업데이트, 원자적 연산, 삭제.
 - 주요내용
	- 도큐먼트 업데이트
	- 도큐먼트의 원자적 프로세싱
	- 실제 예제에 복잡한 업데이트 적용
	- 업데이트 연산자의 사용
	- 도큐먼트 삭제

## 도큐먼트 업데이트
 - MongoDB 업데이트 두 가지 방법
	- 전체를 대치
	- 업데이트 연산자 사용하여 특정 필드 수정

### 대치에 의한 수정
~~~
	user_id = ObjectId("4c4b1476238d3b4dd5003981")
	doc = db.users.findOne({_id: user_id})
	doc['email'] = 'mongodb-user@mongodb.com'
	print('updating ' + user_id)
	db.users.update({_id: user_id}, doc)
~~~
 - 사용자 _id를 가지고 먼저 도큐먼트 질의 후 email 속성 수정 후에 전체 도큐먼트를 대치.
 
### 연산자에 의한 수정.
~~~
	user_id = ObjectId("4c4b1476238d3b4dd5000001")
	db.users.update({_id: user_id}, {$set: {email: 'mongodb-user2@mongodb.com'}})
~~~
 - 서버에 한 번의 요청으로 이메일 주소를 수정하기 위해 update 연산자 중 하나인 $set을 사용.
	- 주어진 고전으로 사용자 도큐먼트를 찾아서 email 필드를 mongodb-user2@mongodb.com로 수정.

### 결정: 대치 vs 연산자
 - 두 가지 방법 중 한가지를 선택하는 기준은?
	- 대치에 의한 수정은 좀 더 일반적인 방식.
		- 사용자의 어떤 속성을 수정하든지 상관없이 업데이트를 수행하는 코드는 동일
	- 타깃 방식의 수정.
		- 수정할 도큐먼트를 가져오기 위해 서버에 도큐먼트 요청을 할 필요 없음
		- 업데이트를 지정하는 도큐먼트의 크기가 일반적으로 작음
		- 도큐먼트를 원자적으로 업데이트하는 데 적합
			- ex ) 카운터를 증가할 필요가 있다면 대치 방식을 통한 업데이트는 결코 좋은 방식이 아님
				- 만약 도큐먼트를 읽고 쓸 때 변경이 발생한다면??
					- 원자적으로 수행할 수 있는 유일한 방법은 일종의 낙관적 잠금(optimistic locking)을 통해서임.
					- 타깃 업데이트는 $inc를 사용해서 카운터를 자동으로 증가할 수 있다.
						- 이것은 대량의 동시적 업데이트일지라도 각각의 $inc는 고립적으로 적용되어 증가되거나 증가되지 않거나 둘 중의 한가지만 가능하다.

###  낙관적 잠금
 - 낙관적 잠금 혹은 낙관적 동시성 제어는 레코드를 잠그지 않고도 업데이트 연산이 제대로 수행되는 것을 보장하기 위한 기술.  
 - 이 기술을 이해하는 가장 쉬운 방법은 위키를 생각해 보는 것. 위키에서는 하나의 페이지를 여러 사용자가 동시에 수정 가능하다.
 - 하지만 수정하고 저장할 때 다른 사람에 의해 수정된 내용을 덮어쓰게 되는 경우는 결코 원치 않을 것임. 따라서 낙관적 잠금 프로토콜이 사용됨. 
 - 사용자가 수정한 후에 업데이트 하려고 할 때 타임스탬프 포함시킴. 그 타임스탬프가 페이지의 최종 저장 시간보다 더 이전이면 업데이트를 할 수 없음. 하지만 아무도 그 페이지에 대해 수정하지 않았다면 업데이트가 가능하다.
	- 이 전략은 여러 사용자가 동시에 페이지를 수정하는 것을 가능하게 하는데 사용자가 페이지를 수정하기 위해 lock을 해야 하는 다른 동시성 제어보다 훨씬 낫다.
	
### MongoDB 업데이트와 삭제
 - 업데이트는 기본적으로 쿼리 셀렉터와 일치하는 첫 번째 도큐먼트만 함.
	- 일치하는 모든 도큐먼트를 업데이트하려면 다중 업데이트라고 명확하게 알려 줘야 한다.
 - 업데이트는 도큐먼트 수준에서 원자적임. 즉, 10 개의 도큐먼트를 업데이트해야 하는 경우 처음 세 개를 업데이트한 후 어떤 이유로 실패할 수 있다.
	- 애플리케이션은 자체적인 정책에 따라 이러한 실패를 처리해야 함.
	
### 업서트
 - 아이템이 없을 경우 새로 추가하고 이미 있다면 업데이트를 하는 것이 일반적으로 필요한 일.
	- 구현하기 까다로운 이러한 패턴은 보통 MongoDB의 업서트로 처리.
 - 간단한 예
~~~
db.products.update({slug: 'hammer'}, {$addToSet: {tags: 'cheap'}}, {upsert: true})
~~~
 - 업서트는 한 번에 하나의 도큐먼트만 삽입하거나 업데이트 할 수 있음.
	- 원자적으로 업데이트 하거나 도큐먼트가 존재하는지의 여부가 불확실할 때 유용하다.

### 업데이트 연산자
 - $inc 연산자는 수치가 증가하거나 감소할 때 사용.
~~~

db.products.update({slug: "shovel"}, {$inc: {review_count: 1}})

~~~
 - $set
	- 도큐먼트에서 특정 키의 값을 정해 주려면 $set을 사용
	- 키에 대한 값이 존재하면 그 값을 덮어쓰고, 그렇지 않을 경우는 새로운 키를 생성
~~~

db.readings.update({_id: 324}, {$set: {temp: 97.6}})

~~~
 - $unset
	- $unset은 도큐먼트에서 해당 키를 삭제.
~~~

db.readings.update({_id: 324}, {$unset : {temp: 1}})

~~~
 - $rename
	- 키의 이름을 바꿔야 할 경우에는 $rename을 사용
~~~

db.readings.update({_id: 324}, {$rename : {'temp': 'temperature'}})

~~~

 - $setOnInsert
	- 업서트 중에 관리해야 되는 데이터를 덮어 쓰지 않도록 조심해야 함.
		- 이 경우 업데이트가 발생할 때가 아니라 도큐먼트가 새 것이고 삽입을 수행할 때만 필드를 수정하도록 지정하는 것이 유용.
~~~

db.products.update({slug: 'hammer'}, {$inc : {quantity: 1}, $setOnInsert: {state: 'AVAILABLE'}}, {upsert: true})

~~~

 - 배열 업데이트 연산.
	 - $push, $pushAll, $each
		- 배열에 값을 추가해야 한다면 $push 를 사용. 배열 끝에 단일 요소를 추가함.
		- db.products.update({slug: 'shovel'}, {$push: {tags: 'tools'}})
	 - $pushAll 연산자는 완전히 제거될 수 있으므로 가급적 사용을 피하는 것이 좋음.
~~~

// 태그를 여러개 추가 시
db.products.update({slug: 'shovel'},  {$push: {tags: {$each: ['tools','dirt','garden']}}})

~~~
 - $slice
	 - $push, $each 연산자와 함께 사용해야 함. 결과 배열을 특정 크기로 잘라서 이전 버전을 먼저 제거할 수 있음.
~~~
// 다음과 같은 도큐먼트가 있을 시
{
	_id: 326,
	temps: [92, 93, 94]
}

// 아래와 같이 업데이트 할 경우
db.temps.update({_id: 326}, {
	$push: {
		temps: {
			$each: [95, 96],
			$slice: -4 // 특정 크기로 자름
		}
	}
})

// 업데이트 후 도큐먼트
// 다음과 같은 도큐먼트가 있을 시
{
	_id: 326,
	temps: [93, 94, 95, 96] // 만약 -4가 아닌 4를 사용했으면 결과는 temps: [92,93,94,95] 가 되었을 것임. 
}


~~~
 - $sort 
	- $push 및 $slice를 사용하면 배열의 시작 부분에서 도큐먼트를 분할하기 전에 정렬하려고 할 때가 있음.
	- 만약 서브도큐먼트들을 배열에 놓고 분할 시 먼저 day 기준으로 정렬 후 분할 
 - $addToSet 과 $each
	 - $addToSet은 배열에 값을 첨가하지만 이것을 좀 더 분별적으로 주행. 즉, 배열에 존재하지 않을 경우에만 값을 첨가.
	 - 하나 이상의 값에 대해서 수행하고자 한다면 $each 연산자와 함께 사용해야 함.
 - $pop
	- 배열에서 아이템을 삭제하는 가장 기본적인 방법.
	- 마지막 아이템 삭제 시 1, 첫번째 아이템 삭제 시 -1 을 받음.
 - $bit 
	- MongoDB 업데이트 상에서 비트단위 OR 연산과 AND 연산을 할 수 있게 해줌.
 - $pull과 $pullAll
	- $pull은 좀 더 정교한 $pop 
		- 배열에서 원소의 위치 대신 값을 지정해서 아이템을 삭제.
	- $pullAll 은 $pushAll과 유사, 삭제할 값의 리스트를 저장할 수 있음.

### 위치 업데이트
 - 위치 연산자는 쿼리 셀렉터에서 닷 표기법을 사용하여 식별한 배열 내의 서브도큐먼트를 업데이트 할 수 있게 해줌.

> ex) 다음과 같은 주문 도큐먼트가 있다고 가정 시
~~~
{
	_id: ObjectId("6a5b1476238d3b4dd500048"),
	line_items: [ // <-- 비정규화된 상품정보
		{
			_id: ObjectId("4c4b1476238d3b4dd5003981"),
			sku: "9092",
			name: "Extra Large Wheelbarrow",
			quantity: 1,
			pricing: {
				retail: 5897,
				sale: 4897
			}
		},
		{
			_id: ObjectId("4c4b1476238d3b4dd5003982"),
			sku: "10027",
			name: "Rubberized Work Glove, Black",
			quantity: 2,
			pricing: {
				retail: 1499,
				sale: 1299
			}
		}
	]
}
~~~

- SKU 가 10027인 두 번째 주문 아이템의 수량을 5로 수정하길 원할 때 문제는 line_items 배열에서 해당 서브도큐먼트가 어디에 있는지 모름.
	- 심지어 그런 도큐먼트가 존재하는지 여부조자 알 수 없음.
	- 하지만 간단한 쿼리 셀렉터와 위치 연산자를 사용한 업데이트가 이 두가지 문제를 해결한다.
~~~
query = {
	_id: ObjectId("6a5b1476238d3b4dd500048"),
	'line_items.sku': "10027"
},
update = {
	$set: {
		'line_items.$.quantity' : 5
	}
},
db.orders.update(query, update)
~~~

 - line_items.$.quantity 에서 $가 위치 연산자임.
	- 이 위치 연산자를 SKU가 10027인 도큐먼트의 인덱스로 대치하고, 그 결과 해당 도큐먼트를 업데이트하게 됨.
	- 데이터 모델에 서브도큐먼트가 있다면 세밀한 도큐먼트 업데이트에 위치 연산자가 매우 유용하다는 사실을 알게 될 것임.
	
### findAndModify 명령
~~~
doc = db.orders.findAndModify({
	query: {
		user_id : ObjectId("4c4b1476238d3b4dd5000001")
	},
	update: {
		$set: {
			state: "AUTHORIZING"
		}
	}
})
~~~
 - 옵션
	- query - 도큐먼트 쿼리 셀렉터이고 디폴트 값은 {}
	- update - 업데이트할 내용을 지정하는 도큐먼트이고 디폴트 값은 {}
	- remove - 부울값으로 true 이면 객체를 삭제하고 삭제한 객체를 반환. 디폴트 false
	- new - 부울값으로 true이면 업데이트를 수행한 후에 업데이트가 적용된 도큐먼트를 반환. 디폴트 false
	- sort - 정렬 방향을 결정하는 도큐먼트. findAndModify가 한번에 하나의 도큐먼트를 수정하므로 이 옵션은 일치하는 도큐먼트 중에서 어떤 것을 처리해야 하는지를 정하는 데 사용됨.
	- field - 일부의 필드만 필요하다면 이 옵션을 사용해서 필요한 필드를 지정.
	- upsert - true 이면 findAndModify를 업서트처럼 수행.

### 삭제
 - db.reviews.remove({})
 - db.reviews.remove({user_id: ObjectId('4c4b1476238d3b4dd5000001')})

### 동시성, 원자성, 고립
 - MongoDB에서 동시성(concurrency) 이 어떻게 수행되는지 이해하는 것이 중요함.
 - MongoDB v2.2 는 데이터베이스 레벨 잠금으로 변경. 데이터베이스 레벨에 적용됨.
 - MongoDB v3.0에서 WiredTiger 스토리지 엔진은 컬렉션 레벨에서 작동하며, 도큐먼트 수준의 잠금 기능을 제공.
	- 다른 스토리지 엔진은 다른 특성을 제공할 수 있을 것임.
 - 잠금 기능은 상당히 많은 동시성 최적화가 존재하므로 실제보다 훨씬 더 좋지 않게 들릴 수 있음.
	- 하나는 램에 있는 도큐먼트의 내부 맵을 데이터베이스가 유지한다는 것.
	- 램에 있지 않은 도큐먼트를 읽거나 쓰려는 요청의 경우 도큐먼트아 메모리로 페이징될 때 까지 다른 작업을 수행.
 - 쓰기 잠금을 양보하는 방법으로 최적화 가능.
	- 쓰기 연산이 오래 걸리면 다른 모든 읽기와 쓰기 연산은 원래의 쓰기가 완료될 때까지 블록됨.
	- 모든 삽입, 업데이트 삭제 연산은 쓰기 잠금을 수행하며 삽입 연산은 오래 걸리는 경우는 거의 없으나 업데이트나 삭제의 경우 전체 컬렉션에 영향을 미치는 경우에는 오래 실행될 수 있다.
		- 이 문제에 대한 현재의 해결책은 오랜 시간이 소요되는 연산을 주기적으로 다른 읽기와 쓰기에게 양보하는 것.
		- 잠시 연산을 멈추고 잠금을 해제했다가 나중에 연산을 재개.
 - 이러한 최적화에도 불구하고 MongoDB의 잠금은 읽기가 많고 쓰기가 많은 작업 부하의 성능에 영향을 미칠 수 있음.
	- 문제를 피하는 좋은 방법은, 특히 MMAPv1 스토리지 엔진을 사용하는 경우 트래픽이 대량으로 발생하는 컬렉션을 별도의 데이터베이스에 저장하는 것.
		- 그러나 MongoDB 3.0 은 WiredTiger가 데이터베이스 레벨이 아닌 컬렉션 레벨에서 작동하므로 이런 상황에서는 훨씬 좋은 편.
 - 도큐먼트를 업데이트하고 삭제할 때 이러한 양보는 장단점이 있음.
	- 어떤 연산이 수행되기 전에 반드시 모든 도큐먼트를 업데이트하거나 삭제해야만 하는 상황을 쉽게 생각해 볼 수 있음.
		- 이런 경우에 $isolated 라는 특수한 옵션을 사용해서 해당 연산이 양보되지 못하도록한다.
		
> ex ) $isolated 사용 예
~~~

db.reviews.remove({user_id: ObjectId("4c4b1476238d3b4dd5000001"), $isolated: true})

~~~

> 다증 업데이트에 대해서도 동일하게 적용 가능

~~~

db.reviews.update({$isolated: true}, {$set: {rating: 0}}, {multi: true}) 

~~~

- 위 명령문은 각 리뷰의 평점을 0으로 만듬.
	- 이 연산은 고립되어 수행해서 양보를 하지 않음으로써 시스템의 일관성을 보장.
	- $isolated을 사용한 연산이 중간에 실패하면 롤백이 발생하지 않음.

### 업데이트 성능.
 - 디스크의 도큐먼트 업데이트할 때 세가지 종류가 있음.
	- 첫번째는 가장 효율적인 것인데, 하나의 값만 수정하고 전체 BSON 도큐먼트의 크기는 변하지 않을 때.
		- 가장 일반적인 경우는 $inc 연산자를 사용할 때 발생.
	- 두번째 종류는 도큐먼트의 크기나 구조를 바꾸는 업데이트.
		- 도큐먼트에 대해 $push 연산자를 사용하면 전체 크기와 구조를 변경하게 된다.
			- 이것은 곧 전체 도큐먼트를 디스크에 대시 쓰기를 해야 한다는 것임.
				- 최악으로 비효율 적인 것은 아니지만 알고 있는것이 좋음.
				- ex) 4MB 정도나 되는 크기의 도큐먼트 내의 배열에 대해 값을 첨가한다면 서버 단에서 많은 일을 수행해야 할 확률이 높음.
	- 마지막 종류의 업데이트는 도큐먼트를 다시 쓰기 할 때의 업데이트.
		- 도큐먼트가 확장되고 디스크에서 할당된 공간 내에 들어갈 수 없으면 다시 쓰기를 해야 할 뿐만 아니라 새로운 공간으로 이동까지 해야한다.
			- 이것이 자주 발생하면 리소스가 많이 필요.
			- MongoDB에서는 컬렉션에 대해 패딩지수를 동적으로 제어함으로써 이 문제를 완화하고자 함.
			- 주어진 컬렉션 내에서 도큐먼트가 재배치되어야 하는 업데이트가 많이 발생 시 내부적인 패딩 지수가 증가.
				- 이 패딩 지수와 삽입되는 각 도큐먼트의 크기를 곱해서 원래의 크기보다 더 큰 도큐먼트를 생성하기 위한 추가 공간의 양을 산정한다.
					- 이러한 방식은 이후에 발생할 수도 있는 도큐먼트 대배치의 발생 횟수를 줄임.
					- 패딩지수 확인 통계명령 -> db.tweet.stats()
						- ex) 패딩 지수가 1.2일 경우 100배이트의 도큐먼트 삽입 시 디스크에는 120바이트를 할당.

