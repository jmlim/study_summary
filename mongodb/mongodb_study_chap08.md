# 8장. 인덱싱과 쿼리 최적화

## 8장 주요 내용.
 - 인덱싱의 기본 개념과 이론
 - 인덱스 관리를 위한 실용적인 조언
 - 복잡한 쿼리에 대한 복합 인덱스 사용
 - 쿼리 최적화
 - 모든 MongoDB 인덱싱 옵션
 
### 인덱싱의 이론적 고찰
 - 5천 페이지의 요리책 예
	- 인덱스 없이 로즈메리 감자 요리법 찾을 수 있을까?
		- 요리책을 처음부터 훑어나가면 됨.
		- 그 요리법이 3,973 페이지에 있다면 3,973 페이지까지 봐야 한다.
		- 최악의 경우 마지막 페이지에 요리법이 있을 수도 있음.
		- 해결책은 인덱스 생성.
 - 단순 인덱스
	- 요리법을 찾기 위해 여라가지 방법을 생각해 낼 수 있겠지만, 가장 좋은 방법은 요리법의 이름으로 찾는 것.
	- 요리책 끝에 각 요리법의 이름과 페이지 번호를 알파벳순으로 나열해 놓는다면 그 책은 요리법의 이름에 의해 인덱스가 된 것.
		- ex : 티베트 야크 수페 : 45, 구운 소금 덤플링 : 4,011 , 터키 알라팅: 943
	- 요리법의 이름을 알거나 혹은 그 이름의 처음 몇 글자만이라도 안다면 이 인덱스를 이용해서 요리법을 신속하게 찾을 수 있다.
		- 하지만 요리명에 의한 인덱스만 가지고 잇는 것은 비현실적.. 식료품 그릇에 있는 재료로 만들 수 있는 요리를 찾거나 지역에 따른 요리법을 찾을 수도 있기 때문..
			- 이 경우에는 좀 더 많은 인덱스가 필요
		- 또한 요리법의 이름에 대한 인덱스만 가지고 있는 상황에서 닭으로 만들 수 있는 모든 요리를 어떻게 찾지?
			- 여기에 적합한 인덱스가 없으므로 또다시 5,000 페이지를 다 넘기면서 닭 요리를 찾아야 함.
			- 이것은 재료나 지역에 따른 요리법을 찾을 때나 마찬가지..
			- 따라서 또 다른 인덱스를 만들어야 하는데, 이번에는 대료에 대한 인덱스다. 
				- 이 인덱스에는 재료를 알파벳 순서로 정렬하고, 그 재료가 들어가는 요리법에 대한 페이지 번호를 모두 나열한다.
				- 재료에 대한 가장 기초적인 인덱스는 다음과 같을 것이다.
					- 캣슈: 3; 20; 42; 88; 103; 1,215 ...
					- 콜리플라워: 2; 47; 88; 90; 275 ...
					- 커런트: 1,001; 1,050, 2,000; 2,133 ...
				- 이 인덱스는 여러분이 생각했던 인덱스인가? 이것은 유용할까?
 - 복합 인덱스
	- 주어진 재료에 대한 요리법의 리스트만 필요하다면 위 인덱스로 충분
	- 하지만 요리법에 관한 어떤 다른 정보를 찾고 있다면 여전히 이 리스트에 나오는 요리법을 일일이 살펴봐야 한다.
		- 일단 콜리플라워가 들어간 요리법이 나와 있는 페이지 번호를 알아낸 후 해당 페이지로 가서 요리법의 이름과 어느지역 음식인지를 알아낸다.
		- 모든 페이지를 다 넘겨보는 것보다는 낫지만 여전히 개선의 여지가 있음.
	- 지금까지 만든 두 개의 인덱스는 단일 키에 대해 생성한 인덱스.
		- 각 요리법에서 오직 하나의 데이터만으로 정렬.
		- 인덱스에 대한 한가지의 데이터 아이템만을 사용하지 않고 두 가지의 데이터를 사용할 것. 
		- 이렇게 하나 이상의 키를 사용하는 인덱스를 복합 인덱스(compound index) 라고 부름.
	- 여기서 복합 인덱스는 재료와 요리명을 재료, 요리명의 순서로 사용.
		- 이런 인덱스를 ingerdient-name이라고 표기.
		- 재료로 검색할 수 있고 이름을 앞부분밖에 기억하지 못한다고 해도 재빨리 원하는 요리법을 찾을 수 있을 것이다.
		- 주의할 사항이 한가지 있는데 복합 인덱스에서는 순서가 중요하다.
			- name-ingredient 라는 순사가 뒤바뀐 복합 인덱스를 생각해보면..
				- 이 새로운 인덱스에서는 일단 요리법 이름으로 찾고 나면 검색은 하나의 요리법, 즉 요리책에서 한 페이지에 국한됨.
				- 따라서 이 인덱스가 '캐슈 메리네이드' 라는 요리법과 '바나나' 라는 재료에 대한 검색에 사용된다면 그런 요리법은 존재하지 않는 것으로 나타난다.
				- 하지만 지금 필요한 것은 그 반대의 경우로 재료를 알고 있지만 요리 이름은 모른다.
 
 > 요리책은 이제 요리법 이름, 재료, 재료-이름, 이렇게 세개의 인덱스를 갖게 되었다. 이들 중 재료에 대한 단일키 인덱스는 없어도 된다. 재료만 지정해서 검색할 때는 재료-이름에 대한 인덱스를 사용할 수 있기 때문이다.
 재료를 알고 있다면 복합 인덱스를 탐색하면서 해당 재료를 포함하고 있는 모든 페이지 번호의 리스트를 얻을 수 있다.
 
- Single(단일) 필드 인덱스
	- _id에 대해 디폴트로 생성되는 인덱스가 좋은 예
	- MongoDB 드라이버가 지정하는 _id 인덱스 외에도, 사용자가 지정 할 수 있는 단일 필드 인덱스가 있음.
- Compound (복합) 필드 인덱스
	- 두개 이상의 필드를 사용하는 인덱스. 
	- ex) 제조사-가격
	- 키의 순서가 매우 중요

### 인덱스 효율
 - 쿼리 성능을 위해서는 인덱스가 반드시 필요하지만, 각 인덱스는 유지 비용이 들어감.
	- 어떤 컬렉션에 도큐먼트를 추가할 때마다 그 컬렉션에 대해 생성된 인덱스도 그 새로운 도큐먼트를 포함시키도록 수정해야함.
 - 읽기 위주의 애플리케이션에서 인덱스 비용은 인덱스로 인해 얻을 수 있는 효과로 상쇄됨.
	- 그러나 인덱스는 비용이 발생하니 조심해서 생성해야 한다.
		- 사용되지 않는 중복된 인덱스가 존재하면 안됨.
 - 모든 인덱스가 적합하게 만들어졌다고 해도 쿼리를 빠르게 처리하지 못할 가능성이 여전히 존재함.
	- 이것은 인덱스와 현재 작업중인 데이터를 램에서 다 처리하지 못할 때 발생함.
	- 데이터를 수용하지 못하면 점점 페이지 폴트가 발생하는데 이것은 OS가 디스크를 빈번하게 액세스함으로써 읽기와 쓰기 연산이 매우 느려지게 된다는 것을 뜻함.
	- 최악의 경우에는 데이터의 크기가 램의 크기보다 훨씬 커서 모른 읽기와 쓰기에 대해 디스크 액세스를 해야 하는 상황이 발생할 수도 있음.
		- 쓰레싱(thrashing)이라고 함
	- 이런 현상은 쉽게 피할 수 있는데 인덱스만큼은 램에 들어가도록 하면 된다.
		- 필요없는 인덱스를 만들지 말아야할 중요한 이유.
		- 인덱스와 현재 작업중인 데이터가 모두 램에 존재해야 이상적임.
			-stats 명령을 통해 전체 인덱스 크기 확인 가능.
### B-트리
 - 몽고디비는 내부적으로 b-tree로 인덱스를 생성함.
 - 내용 참고 : https://ko.wikipedia.org/wiki/B_%ED%8A%B8%EB%A6%AC
 
## 인덱싱의 실제
### 인덱스 타입
 - 고유 인덱스(unique index)
	- 종종 _id 또는 username과 같은 도큐먼트의 필드가 해당 도큐먼트에서 고유한지 확인하는 경우가 있음.
	- 고유 인덱스(unique index)는 이 특성을 강화하는 방법.
	- 고유 인덱스를 생성하기 위해선 인덱스 생성 시 unique 옵션을 지정한다.
	- 	ex) db.users.createIndex({username: 1}, {unique: true})
	- 고유 인덱스는 컬렉션에 데이터가 존재하지 않을 때 생성하는 것이 좋음.
	- 고유 인덱스를 걸려고 하는 컬럼에 중복 데이터 존재 시 실패한다.
	- 기존에 존재하는 컬렉션에 대해 고유 인덱스 생성시 몇가지 옵션이 있음.
		- 고유 인덱스 생성을 반복적으로 수행하고 발생하는 실패 메시지를 이용해 중복키를 없애는 방법.
		- 하지만 데이터가 그다지 둥요하지 않다면 데이터베이스로 하여금 dropDups 옵션을 이용해 중복 키를 가지고 있는 도큐먼트를 자동으로 삭제하도록 명령을 내릴 수 있음.
			- ex) user 컬렉션에 이미 데이터가 있고 중복된 키 값을 갖는 도큐먼트를 삭제해도 무방하다면 다음과 같이 인덱스 생성 명령을 수행 할 수 있다.
			- 3.x 에서 삭제됨.. 이기능에 대한 대체옵션 존재x, 새 컬렉션을 만들고 새 컬렉션에 고유 인덱스를 만들고 이전 컬렉션의 모든 도큐먼트를 복사하는 방법 또는 위 방법 권장.

 - 희소 인덱스(sprase index)
	- 인덱스는 밀집(dense) 하도록 기본 설정되어 있음.
		- 밀집 인덱스란 컬렉션 내의 한 도큐먼트가 인덱스 키를 가지고 있지 않더라도 인덱스에는 해당 엔트리가 존재한다는 것을 뜻함.
		- 예를 들어, 우리가 이미 살펴봤던 전자상거래 데이터 모델에서 상품 컬렉션에 대해 category_id 로 인덱스를 생성했는데, 카테고리가 지정되지 않은 상품이 몇개 있다고 가정 해보자. 이 카테고리가 없는 상품들에 대해 category_id 인덱스는 널 값을 갖는 엔트리를 갖게 된다.
		- ex) db.products.find({category_ids: null})
		- 카테고리를 갖지 않는 모든 상품을 검색할 때 쿼리 옵티마이저(query optimizer)는 이 상품들을 찾기 위해 category_id 인덱스를 사용할 수 있다.
	- 밀집 인덱스가 바람직하지 않은 경우..
		- 모든 도큐먼트가 다 가지고 있지는 않은 필드에 대해 고유인덱스를 생성할 때.
			- ex) sku 라는 필드에 고유 인덱스가 이미 생성되어 있는 상황에서 sku 필트를 갖지 않는 도큐먼트를 여러개 삽입하려고 하면 첫 번째 삽입은 성공하지만 그 이후의 삽입 연산은 실패한다.
			- sku 에 null인 엔트리가 이미 존재하므로.. 그 대신 희소 인덱스(sprase index) 가 필요하다.
 
 
 작성중..