
# 4장 주요 내용.
### 1. 도큐먼트 지향 데이터
 - 스키마 설계
 - 전자상거래 데이터 모델
 - 데이터베이스, 컬렉션, 도큐먼트의 실제적 세부사항들.
 
### 2. 전자상거래 스키마 설계를 살펴보며 이 과장에서 RDBMS의 스키마와 어떻게 다른지 설명.
### 3. MongoDB에서 일대다, 다대다와 같이 개체 간의 관계가 어떻게 표현되는지 확인.
### 4. 지금까지 다뤘던 것보다는 훨씬 더 자세하게 데이터베이스, 컬렉션 도큐먼트에 대해 논의.


## 4.1. 스키마 설계 원리.
### RDBMS 에서는 정규화된 데이터 모델을 권장
- 이것은 일반적인 질의성(query ability)을 보장하고 무결성을 해칠수도 있는 데이터 업데이트를 피하는데 도움이 됨.
- 패턴이 이미 확인되어 있어서 개발자들은 RDBMS 에서 일대다, 다대다 관계를 생성하는 방법을 이미 알고 있음.
- 하지만 애플리케이션 기능과 성능은 스키마 설계에서 궁극적으로 중요한 요소이므로 모든 규칙은 예외를 가지게 됨.

### 기존 RDBMS를 사용했던 사람이면 MongoDB에 스키마 설계 규칙이 없는것에 당황.
- 일반적으로 받아들여질 만한 선례가 MongoDB에서도 나타나고 있지만, 솔직히 말해서 주어진 데이터를 모델링할 때 좋은 방법이 한가지만 있는게 아닐때가 종종 있다.
- 이론에 따라 스키마를 설계해야 하지만, 실제에서는 이론을 융통성 있게 적용한다라는 전제를 바탕으로 한다.

### 어떠한 데이터베이스 시스템으로 모델링을 하더라도 제기할 수 있는 질문은 다음과 같음.
- 애플리케이션의 액세스 패턴은 무엇인가?
	- 애플리케이션의 요구사항이 무엇인지 정확하게 파악할 필요가 있다.
		- MongoDB가 모든 애플리케이션에 적합한 것은 아님.
		- 애플리케이션 액세스 패턴을 이해하는 것은 스키마 설계에서 가장 중요한 부분.
	- 데이터모델을 결정하는데 도움을 얻기 위해서는 애플리케이션에 관해서 여러가지 질문을 해야함.
		- 읽기/쓰기 비율은 어떻게 되는가?
		- 쿼리는 키를 찾는 정도로 쉬운가? 아니면 더 복잡한가?
		- 집계는 필요한가?
		- 데이터는 얼마나 저장되는가?
- 데이터베이스에는 어떤 기능이 있는가?
	- 데이터의 기본 단위가 있으면 그것을 조작하는 법을 배워야 함.
	- 간단한 키-값 저장 시스템이 하나의 키에 대해셔만 값을 가져올 수 있는 반면에 RDBMS 는 애드혹 쿼리와 조인이라는 특징이 있다.
	- MongoDB 또한 애드혹 쿼리를 허용, 조인은 지원하지 않음.
	- MongoDB는 기존 방식의 트랜잭션을 지원하지 않지만, 복잡한 도큐먼트의 내부 구조에 대해 수행할 수 있는 원자적인 업데이트를 다양하게 지원.
- 좋은 고유 식별자(unique id)와 프라이머리 키를 무엇으로 만드는가?
	- 예외가 있긴 하지만, 데이터베이스에 관계없이 많은 스키마들이 고유한 키를 갖는다.
	- 이러한 키를 고르는 것은 데이터를 접근하는 방식과 저장하는 방식에서 큰 차이를 만들어 낼 수 있다.
		- 예를 들어, 사용자들의 컬렉션을 설계하고 있다면 임의의 값, 법적인 성명, 사용자 이름, 또는 사회보장 번호를 프라이머리 키로 사용해야 하나?
		- 모든 사용자들에게 적용할 만한 것은 아님.
	- MongoDB 에서 primary key를 선택하는 것은 어떤 값이 _id 필드에 채워질 것인지 고르는 것을 뜻함.
		- 자동으로 생성되는 객체 id는 기본 설정으로 나쁘지 않지만, 모든 경우에 이상적인 것은 아니다.
		- 여러 장비에 데이터를 샤딩하는 경우라면 이는 특히 중요한데, 특정 행이 저장될 곳을 결정하기 때문.


## 4.2. 전자상거래 데이터 모델 설계

- 전자상거래는 익숙한 데이터 모델링 패턴을 많이 가지고 있음.
	- 상품, 카테고리, 상품명, 주문이 통상적으로 RDBMS에서 어떻게 모델링되는지 쉽게 생각할 수 있다.
- 전자상거래는 전적으로 RDBMS에 속한 도메인
	- 트랜잭션 필요.
	- 다양한 데이터 모델과 동적인 쿼리가 RDBMS에 가장 적합.
	- 전자상거래의 백엔드 시스템 전체를 구축하는 것은 이 책의 분량으로는 현실적이지 않음.
		- 상품, 고객 리뷰와 같은 보편적이고 유용한 전자상거래 개체들을 몇 개 선택해서 MongoDB로 어떻게 모델링 하는지를 보일 것이다.
- 많은 개발자에게 데이터 모델(data model)과 객체 매핑(object mapping) 은 떼어서 생각할 수 없다.
	- 이러한 객체 매핑을 위해 자바의 hibernate나 루비의 ActiveRecord 같은 ORM 사용.
		- RDBMS 상에서 애플리케이션을 효율적으로 개발하기 위해서는 대부분의 경우에 그러한 라이브러리 필요.
		- MongoDB에서는 ORM에 대한 필요성이 상대적으로 낮음.
			- 도큐먼트가 이미 객체와 같은 표현
			- 드라이버가 사용하기 쉬움
	- 객체 매퍼는 인증, 타입 체킹, 그리고 모델관의 연관(association)을 용이하게 해줌.
	- MongoDB를 처음 배울땐 객체 매퍼를 사용하지 않는것을 권장.
	
### 4.2.1. 스키마 기본 
 - 어떠한 상품 도큐먼트라도 상품이 필요로 하는 동적인 속성을 받아들일 수 있다.
 - 도큐먼트 내에서 배열을 사용하면, RDBMS에서 여러 개의 테이블로 표현되는 것이 MongoDB에서는 하나의 컬렉션으로 줄어들 수 있다.

샘플 상품 도큐먼트
 - 도큐먼트는 기본적인 name, sku, description 필드를 가지고 있음. 또한 _id필드에는 MongoDB 객체 ID가 저장되어 있다.
> 4.1. 샘플 상품 도큐먼트
~~~
{
	_id: ObjectId("4c4b1476238d3b4dd5003981"), // 1. 고유 객체 ID
	slug: "wheelbarrow-9092", // 2. 고유 슬러그
	sku: "9092",
	name: "Extra Large Wheelbarrow",
	description: "Heavy duty wheelbarrow...",
	details: {  // 3. 중첩 도큐먼트
		weight: 47,
		weight_units: "lbs",
		model_num: 4039283402,
		manufacturer: "Acme",
		color: "Green",
	},
	total_reviews: 4,
	average_review: 4.5,
	pricing: {
		retail: 589700,
		sale: 489700
	},
	price_history: [                       // 4. primary_category와 price_history는 1대 다 관계
		{
			retail: 529700,
			sale: 429700,
			start: new Date(2010,4,1),
			end: new Date(2010,4,8)
		},
		{
			retail: 529700,
			sale: 529700,
			start: new Date(2010, 4, 9),
			end: new Date(2010, 4, 16)
		}
	],
	primary_category: ObjectId("6a5b1476238d3b4dd500048"),
	category_ids: [  // 5. 다대다 관계
		ObjectId("6a5b1476238d3b4dd500048"),
		ObjectId("6a5b1476238d3b4dd500049")
	],
	main_cat_id: ObjectId("6a5b1476238d3b4dd500048"),
	tags: ["tools","gardening", "soil"]
}
~~~

#### 고유한 슬러그
 - slug 필드 
	- ex) http://mygadensite.org/products/wheelbarrow-9092
	- 도큐먼트에 대한 URL을 생성할 때는 슬러그 필드를 만들 것을 권함.
	- 그러한 필드에 대해서는 고유 인덱스를 만들어서 해당필드의 값이 빠른 쿼리 접근 및 고유성을 보장하도록 한다.
	- db.products.createIndex({slug: 1}, {unique: true})
		- slug에 대한 고유 인덱스 생성했다면 중복된 값을 삽입 시 exception 발생.

#### 중첩 도큐먼트
- detail
	- 여러가지 상품에 대한 자세한 정보를 갖는 서브도큐먼트.
	- 무게와 무게의 단위, 제조사의 모델 번호가 명시되나 기타 다른 속성도 포함될 수 있다.
		- 상품의 종류에 따라서 
		- 또는 현재의 가격과 과거의 가격 등
		

#### 일대다 관계
 - 상품과 카테고리에 대한 관계를 형성
 - 상품이 오직 하나의 주요 카테고리만 가지고 있지만, 카테고리는 많은 상품들의 주요 카테고리가 될 수 있으므로 이는 일대다 관계.

#### 다대다 관계
 - 각 삼품을 주요 카테고리 외에 관련 있는 카테고리 목록들과 관계를 맺을 수도 있다.
	- 이 경우 각 상품이 하나 이상의 카테고리에 속하고, 각 카테고리 역시 하나 이상의 상품을 가지므로 다대다 관계.
	- RDBMS에서는 이런 다대다 관계를 표현하기 위해 조인 테이블을 이용.
		- 하나의 테이블을 만들어 두 테이블 간의 모든 관계에 대한 참고를 저장.
		- 해당 테이블을 사용하여 join 을 걸면 한 쿼리로 하나의 상품과 그 상품이 속해있는 모든 카테고리나 그 반대의 경우를 모두 불러올 수 있음.
	- MongoDB는 조인을 지원하지 않으므로 다대다 관계를 위해서는 다른 어떤것이 필요.
		- 좀 전에 객체 ID를 가지고 있는 category_ids(5) 라는 필드를 정의한 바 있음.
		- 각 객체 ID는 카테고리 도큐먼트의 _id 필드에 대한 레퍼런스이다.

#### 관계 구조
 - 아래 예 참고, db.categories.insert(newCategory)

> 리스트 4.2. 카테고리 도큐먼트
~~~
{
	_id: ObjectId("6a5b1476238d3b4dd500048"),
	slug: "gardening-tools",
	name: "Gardening Tools",
	description: "Gardening gadgets galore!",
	parent_id: ObjectId("55804822812cb336b78728f9"),
	ancestors: [
		{
			name: "Home",
			_id: ObjectId("558048f0812cb336b78728fa"),
			slug: "home"
		},
		{
			name: "Outdoors",
			_id: ObjectId("55804822812cb336b78728f9"),
			slug: "outdoors"
		}
	]
}
~~~

 - 위 도큐먼트에서 category_ids 필드의 객체 아이디를 주의깊게 살펴보면 이 상품이 가드닝 툴(Gardening Tools) 카테고리에 속해 있는 것을 알 수 있다.
 - 상품 도큐먼트의 category_ids 배열은 다대다 관계에 대한 모든 종류의 질의를 가능하게 한다.
~~~
db.products.find({category_ids: ObjectId('6a5b1476238d3b4dd500048')})
~~~
 - 어떤 상품이 속해 있는 모든 카테고리를 알기 위해서는 $in 연산자를 사용한다.
~~~
db.categories.find({_id: {$in: product['category_ids']})
~~~
 - 이전 명령어는 상품(product) 변수가 이미 다음과 비슷한 명령으로 정의되어 있다고 가정한다.
~~~
product = db.products.findOne({"slug": "wheelbarrow-9092"})
~~~

많은 조상 카테고리 도큐먼트를 왜 이렇게 중복해서 저장해야 할까?
 - 카테고리는 항상 계층 구조로 인식
	- 데이터베이스에서 그러한 계층 구조를 표현하는 방법은 여러가지가 있음.
	- 위의 예에서 'Home' 을 상품 카테고리로 'Outdoors'를 'Home' 의 하위 카테고리로 그리고 'Gardening Tools'를 'Outdoors'의 하위 카테고리로 가정.
	- MongoDB는 조인을 지원하지 않으므로 각 자식 도큐먼트에서 조상 카테고리의 이름을 모두 가지고 있기로 한 것.
		- 가드닝 상품 카테고리에 속한 상품에 대한 쿼리를 수행 시 Outdoors나 home 과 같은 부모 카테고리를 불러오기 위해 추가적인 쿼리를 수행할 필요 X.


### 4.2.2. 사용자와 주문

- 사용자(users)와 주문(order) 을 모델링하는 방법을 살펴보면 또 다른 흔한 관계인 일대다 관계를 설명할 수 있다.
- 이 경우에 사용자는 하나 이상의 주문을 가지고 있고 RDBMS에서는 주문 테이블에서 외래 키를 사용할 것이다.
	- 몽고디비에서도 비슷한 방식 사용

> 리스트 4.3. 아이템, 가격, 배송 주소를 가지고 있는 전자상거래 도큐먼트 (orders)
~~~
{
	_id: ObjectId("6a5b1476238d3b4dd500048"),
	user_id: ObjectId("4c4b1476238d3b4dd5000001"),
	state: "CART",
	line_items: [ // <-- 비정규화된 상품정보
		{
			_id: ObjectId("4c4b1476238d3b4dd5003981"),
			sku: "9092",
			name: "Extra Large Wheelbarrow",
			quantity: 1,
			pricing: {
				retail: 5897,
				sale: 4897
			}
		},
		{
			_id: ObjectId("4c4b1476238d3b4dd5003982"),
			sku: "10027",
			name: "Rubberized Work Glove, Black",
			quantity: 2,
			pricing: {
				retail: 1499,
				sale: 1299
			}
		}
	],
	shipping_address: {
		street: "588 5th Street",
		city: "Brooklyn",
		state: "NY",
		zip: 11215
	},
	sub_total: 6196  // <-- 비정규화된 세일 가격의 합
}
~~~

##### 이 주문 도큐먼트의 두번째 속성인 user_id 는 사용자의 _id 값을 가지고 있음.
 - 아래 리스트 4.4 에서 보이는 것과 같은 샘플 사용자를 가리팀.
 - 이렇게 모델링하면 관계의 어느 쪽에 대해서도 쿼리를 쉽게 할 수 있음.

- 어느 한 사용자가 주문한 모든 주문 찾기.
~~~
db.orders.find({user_id: user['_id']})
~~~
 - 특정 주문에 대한 사용자의 도큐먼트를 얻기 위한 쿼리.
~~~
db.users.findOne({_id: : order['user_id']})
~~~

따라서 주문과 사용자 사이에 존재하는 일대다 관계가 객체 ID를 레퍼런스로 사용해서 쉽게 구현됨.

#### 도큐먼트에 대한 생각.
 - 주문 도큐먼트의 몇가지 눈에 띄는 점.
	- 객체를 전체적으로 표현하기 위해서 도큐먼트의 데이터 모델이 제공하는 다양한 표현 사용.
	- 주문 도큐먼트가 아이템과 배송 주소를 모두 가지고 있으며, 정규화된 관계 모델에서 이런 속성은 별도의 테이블로 표현됨.
	- 주문 아이템은 서브 도큐먼트의 배열로 이루어져 있는데, 각각은 쇼핑 카드에 있는 한 상품을 나타낸다.
	- 배송 주소는 주소 필드를 가지고 있는 하나의 객체를 가리킴
 - 이러한 표현의 장점? 
	- 사람이 이해하기 쉬움.
		- 아이템, 배송 주소, 지불 정보를 포함한 주문의 전반적인 개념이 하나의 개체 안에 들어감.
	- 데이터베이스에 대해 질의할 때 간단한 쿼리로 주문 객체 전체를 반환할 수 있다.
	- 또한 상품이 구매된 후에는 주문 아이템들이 주문 도큐먼트 내에서 효과적으로 동결된다.
	- 주문 도큐먼트에 대한 질의와 수정이 용이

- 사용자 도큐먼트는 주소 도큐먼트의 리스트와 함게 지불 방식 도큐먼트의 리스트를 저장.
- 도큐먼트의 최상위 레벨에서 어떤 사용자 모델에도 공통적인 기본 속성 저장.
- 그리고 상품의 slug 필드와 같이 사용자 이름 필드가 고유 인덱스를 갖는것이 현명함.
	
> 리스트 4.4. 주소와 지불 방식을 가지고 있는 사용자 도큐먼트.
~~~
{
	_id: ObjectId("4c4b1476238d3b4dd5000001"),
	username: "kbanker",
	email: "kylebanker@gmail.com",
	first_name: "Kyle",
	last_name: "Banker",
	hash_password: "bd1cfa194c4a603e7186780824b04419",
	address: [
		{
			name: "home",
			street: "588 5th Street",
			city: "Brooklyn",
			state: "NY",
			zip: 11215
		},
		{
			name: "work",
			street: "1 E. 23rd Street",
			city: "New York",
			state: "NY",
			zip: 10010
		}
	],
	payment_method: [ {
		name: "VISA",
		payment_token: "43f6ba1dfda65b8106dc7"
	}]
}
~~~


### 4.2.3. 상품평
 - 리스트 4.5 에 등장하는 상품평을 마지막으로 살펴본다.
	- 각 상품은 많은 상품평을 가질 수 있고 product_id를 각각의 상품평에 저장함으로써 관계를 만들어 낼 수 있다.

> 리스트 4.5. 상품평을 나타내는 도큐먼트
~~~
{
	_id: ObjectId("4c4b1476238d3b4dd5000041"),
	product_id: ObjectId("4c4b1476238d3b4dd5003981"),
	date: new Date(2010,5,7),
	title: "Amazing",
	text: "Has a squeaky wheel, but still a darn good wheelbarrow.",
	rating: 4,
	user_id: ObjectId("4c4b1476238d3b4dd5000042"),
	username: "dgreenthumb",
	helpful_votes: 3,
	voter_ids: [
		ObjectId("4c4b1476238d3b4dd5000033"),
		ObjectId("7a4f0376238d3b4dd5000003"),
		ObjectId("92c21476238d3b4dd5000032")
	]
}
~~~

- 리뷰한 날짜, 제목, 텍스트와 사용자에 의해 주어진 평점과 사용자의 id를 저장.
	- MongoDB에서는 조인이 없으므로 각 리뷰마다 사용자 컬렉션에 대해 질의하거나 비정규화를 해야함.
	- 위에서는 사용자 이름은 거의 바뀌지 않으므로 user_id 와 사용자이름(username) 을 같이 저장함으로써 매번 사용자 컬렉션을 질의하지 않음
- 상품평 도큐먼트에 추천수를 저장
	- 여기서 추천한 사용자의 객체 ID를 배열로 저장했다.
		- 사용자가 하나의 상품평에 대해 한번 이상 추천하는 것을 막음.
		
	
## 4.3. 실제적 세부사항: 데이터베이스, 컬렉션, 도큐먼트
### 4.3.1. 데이터베이스
 - 데이터베이스는 컬렉션과 인덱스의 물리적인 모음
#### 데이터베이스 관리
 - 컬렉션에 데이터를 쓴 후에야 데이터 파일이 만들어짐
#### 데이터 파일과 할당.
 - 모든 데이터베이스 파일명은 해당하는 데이터베이스의 이름을 따라 정해짐.
 - 예를들면 garden 데이터베이스가 처음 생성된다고 가정할 때 garden.ns 파일이 가장 먼저 만들어진다. 파일 확장자인 ns는 namespace를 뜻한다.
 - 성능을 위해서 항당된 공간과 실제 데이터의 크기가 차이가 많이 날 수 있다.
 - db.stats() 명령을 사용해서 사용하는 공간과 할당된 공간을 언제라도 확인할 수 있다.
 - 몽고디비 구동을 위해 어느정도의 디스크 공간과 RAM이 필요한지 가늠하기 위해 이 정보를 사용해야 함.
	- 예상되는 공간보다 여유롭게 할당하는 것을 권장.
### 4.3.2. 컬렉션
#### 컬렉션 관리
 - 별도의 명령어 없이 도큐먼트를 네임스페이스에 삽입하는 것만으로도 컬렉션 생성.
	- 그러나 컬렉션을 생성하는 별도의 명령어도 있음.
		- db.createCollection("users")
	- 표준적인 컬렉션을 생성할 때 크기를 미리 할당할 수도 있다.
		- db.createCollection("users", {size: 20000})
	- 컬렉션은 반드시 알파벳이나 숫자로 시작해야 한다.
	- 컬렉션의 이름을 바꾸는 것도 가능.
		- db.products.renameCollection("store_products")
#### 캡드 컬렉션.
 - 캡드 컬렉션이라는 것도 있다.
	- 높은 성능의 로깅 기능을 위해 설계
	- 일반 컬렉션과 다르게 고정된 크기를 갖는다.
		- 더 이상의 공간이 없게 되면 도큐먼트를 삽입할 때 컬렉션에 추가된 지 가장 오래된 도큐먼트를 덮어쓰게 된다.
	- 크기 제한뿐만 아니라 max 매개변수로 캡드 컬렉션에 대해 도큐먼트 최대 갯수를 지정 가능.
	- 캡드 컬렉션은 일반적인 보통 컬렉션에 모든 연산이 가능하도록 허용하지는 않음.
		- 한가지 예로 개별 도큐먼트는 삭제 X
		- 도큐먼트의 크기를 증가시키는 어떤 업데이트도 수행 불가.
		- 캡드 컬렉션은 원래 로깅을 위해 만들어진 것이므로 도큐먼트를 삭제하거나 업데이트 하는것을 구현할 필요가 없었음.

~~~
db.createCollection("users.actions", {capped true, size: 16384, max: 100})
~~~

#### TTL 컬렉션
- MongoDB 는 컬렉션에서 특정 시간이 경과한 도큐먼트를 만료(expire) 시킬 수 있는 기능을 제공.
~~~
db.reviews.createIndex({time_field: 1},{expireAfterSeconds: 3600})
~~~
- 위 명령은 time_field에 대한 인덱스를 생성.
	- 주기적으로 타임스탬프 값을 체크하여 현재 시간과 비교 수행.
	- time_field와 현재 시간값의 차이가 expireAfterSeconds 설정 값보다 크게 되면 해당 도큐먼트는 자동으로 삭제될 것.
	- TTL 인덱스를 사용하는 것은 타임스탬프 값을 time_field에 저장했다고 가정한 것이다.

~~~
db.reviews.insert({
	time_field: new Date(),
	....
})
~~~

- 제약사항
	- _id 필드 및 다른 인덱스에서 사용하는 필드는 TTL 인덱스를 못 가짐.
	- 캡드 컬렉션에 대해서도 TTL 인덱스를 가지지 못함.
		- 개별 도큐먼트를 삭제하는 것을 지원하지 않음.
		
#### 시스템 컬렉션
 - 몽고디비 내부에서 컬렉션을 부분적으로 사용.
	- 예)
		- system.namespace
		- system.indexes

### 4.3.3. 도큐먼트와 인서트
#### 도큐먼트 시리얼라이제이션, 타입 그리고 한계
 - 모든 도큐먼트는 MongoDB에 저장하기 전에 BSON 으로 시리얼라이즈(serialize) 되고, 나중에 BSON으로부터 디시리얼라이즈(deserialize) 됨.
 - 드라이버는 이러한 과정을 처리하고, 그 프로그래밍 언어를 통해 적절한 데이터 타입으로 변환.
 - 일반적인 컬렉션에서 도큐먼트의 업데이트는 현재의 공간보다 용량을 더 크게 만들어 해당 도큐먼트를 새로운 곳으로 이동하게 하는 한편 그 컬렉션의 메모리를 빈 상태로 남겨 놓게끔 만듬.
 - 에러없이 시리얼라이즈화 하기 위해서는 키 이름이 유효해야 하고 키의 값이 BSON 타입으로 변환할 수 있어야 함.
    - 키 이름의 허용 길이 : 255 바이트의 문자열
    - 문자열 : 아스키 문자로 이루어져 있으면 유효
        - 세가지 예외
            - $로 시작되어선 안됨.
            - .(마침표) 포함 안됨.
            - 마지막 위치 외에 널(null) 값이 있으면 안됨.
    - 키의 이름이 모든 도큐먼트에 매번 저장되므로 데이터 크기에 영향을 줌..
        - 키를 가지고 있는 도큐먼트가 10억 개라면 짦은 키 이름을 사용하는 것만으로 거의 10GB의 공간을 절약.
            - 의미를 살리면서 최대한 짧은 키 이름을 사용하는 것이 좋다.
 - 도큐먼트가 유효한 키의 이름을 가져야 한다는 점과 함께 키의 값 또한 BSON 형식으로 시리얼라이즈 될 수 있어야 한다.
     - http://bsonspec.org 에는 BSON 타입에 대해 예제와 설명이 함께 소개.

#### 문자열
 - 모든 문자열은 UTF-8 형식이어야 함.
#### 숫자
 - BSON은 double, int, long의 세가지 수 타입을 규정.
#### 날짜와 시간
 - BSON datetime 타입은 시간이나 날짜에 관련된 값을 저장하는 데 사용.
    - 시간은 singed 64비트 정수를 사용해서 유닉스 에폭 이후 지나간 밀리초(millsecond)로 표현.
        - 유닉스 에폭(Unix epoch)은 UTC로 1970년 1월 1일 자정임.
#### 가상타입
 - ex) MongoDB 객체 매퍼인 MongoMapper 에서 복합적인 타입이 가능하도록 어떠한 객체에 대해서도 to_mongo와 from_mongo 메서드를 정의하는 것을 허용.

#### 도큐먼트 크기에 대한 제약.
 - 도큐먼트의 최대 크기는 16MB
    - 과도하게 큰 도큐먼트를 가지는 스키마 방지.
    - 성능과 관계
 - 도큐먼트의 최대 중첩 깊이는 100으로 제한.
    - 예를 들어 트리 데이터 구조를 MongoDB 도큐먼트에 시리얼라이즈 하는 것과 같이 깊게 중첩된 도큐먼트를 사용하는 것은 질의하기 어려운 도큐먼트를 발생시킴.
       - 이는 도큐먼트를 접근하는 동안 문제를 일으킬 수 있음.
 - 만약 크기가 크거나 중첩 제한에 근접한 도큐먼트가 있다면 데이터 모델을 수정해서 한두개의 컬렉션을 추가로 만들어 분할하는 것이 더 나음.
#### 대량 삽입 연산.
 - 여러개의 도큐먼트를 동시에 삽입.
    - 삽입할 도큐먼트를 배열로 정의하여 한번에 보냄.
    - 제한사항은 존재
        - 만약 100만건의 도큐먼트를 삽입할경우? 여러개의 대량 삽입 도큐먼트 그룹으로 나누어야 함.
        - 10에서 200개 사이가 적당하다고 함.
            - 주의 ) 16MB 이상은 허용하지 않음. 이 제한 보다는 작아야함.