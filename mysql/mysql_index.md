## Mysql Index

### 1. 인덱스란?

- 인덱스는 지정한 컬럼들을 기준으로 메모리 영역에 일종의 목차를 생성하는 것.
- insert, update, delete (command)의 성능을 희생하고 대신 "select (Query)의 성능을 향상" 시킴
    - 여기서 주의할 점은 update, delete 행위가 느린것이고, update, delete 를 하기 위해 해당 데이터를 조회하는 것은 인덱스가 있으면 빠르게 조회가 됨.
- 인덱스가 없는 컬럼을 조건으로 update, delete를 하게 되면 굉장히 느려 많은 양의 데이터를 삭제해야 하는 상황에선 인덱스로 지정된 컬럼을 기준으로 진행하는 것을 추천함.


- 인덱스 탐색은 Root -> Branch -> Leaf -> 디스크 저장소 순으로 진행됨.
    - ex) Branch (페이지 번호 2) 는 dept_no 가 d001 이면서 emp_no 가 10017 ~ 10024 까지인 Leaf 의 부모로 있음.
    - 즉, dept_no=d001 and emp_no=10018 로 조회하면 페이지 번호 4인 Leaf 를 찾아 데이터 파일의 주소를 불러와 반환하는 과정을 하게됨.
- 인덱스의 두번째 컬럼은 첫 번째 컬럼에 의존해서 정렬되어 있음.
- 디스크에서 읽는 것은 메모리에서 읽는 것보다 성능이 훨씬 떨어짐.
    - 결국 인덱스 성능을 향상시킨다는 것은 디스크 저장소에 얼마나 덜 접근하게 만드느냐, 인덱스 Root에서 Leaf 까지 오고가는 횟수를 얼마나 줄이느냐에 달려있음.
- 인덱스의 갯수는 3~4개 정도가 적당함.
    - 너무 많은 인덱스는 새로운 Row를 등록할때마다 인덱스를 추가해야하고, 수정/삭제시마다 인덱스 수정이 필요하여 성능상 이슈가 있음.
    - 인덱스 역시 공간을 차지.
    - 특히 많은 인덱스들로 인해 옵티마이저가 잘못된 인덱스를 선택할 확률이 높음.

### 1.1. 인덱스의 종류

- 클러스터형 인덱스와 보조 인덱스로 나뉨.
    - 클러스터형 인덱스는 영어사전, 보조 인덱스는 책 뒷편에 있는 색인이라고 생각하자.
- 클러스터형 인덱스는 테이블당 한개만 생성가능
    - 흔히 우리가 Primary Key로 지정하는 컬럼이 클러스터형 인덱스.
    - 클러스터형 인덱스는 생성과 동시에 오름차순으로 정렬됨.
        - 또한, primary key는 테이블당 한개만 만들 수 있기 때문에 위의 조건을 충족함.
        - 클러스터형 인덱스가 될 수 있는 후보군에는 NOT NULL Uniuqe 제약조건을 경우에도 클러스터형 인덱스가 될 수 있다.
        - 하지만 primary key랑 동시에 만든다면, primary key가 우세함으로 클러스터형 인덱스가 된다.

- 보조 인덱스(비 클러스터형 인덱스)라고도 함.
- 보조 인덱스는 검색(조회)을 용이하게 하기 위해서, 특정 컬럼(열), 컬럼들의 조합을 통해서 인덱스를 생성함.
- 보조 인덱스는 테이블의 컬럼들로 지정할 수 있다.

### 2. 인덱스 키 값의 크기

- InnoDB(MySQL) 은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지라고 함.
    - 인덱스 역시 페이지 단위로 관리됨.
- 페이지는 16KB로 크기가 고정되어 있음.
- 인덱스의 키는 길면 길수록 성능상의 이슈도 존재.

### 3. 인덱스 컬럼 기준.

- 1개의 컬럼만 인덱스를 걸어야 한다면, 해당 컬럼은 카디널리티(Cardinality)가 가장 높은것을 잡아야 함.
    - 카디널리티? 해당 컬럼의 중복된 수치를 나타냄.
        - ex) 성별, 학년 등은 카디널리티가 낮음.
            - 반대로 주민등록번호, 계좌번호 등은 카디널리티가 높다고 얘기함.
    - 인덱스로 최대한 효율을 뽑으려면 해당 인덱스로 많은 부분을 걸러내야 함.
        - ex)  만약 성별을 인덱스로 잡는다면 남/녀 중 하나를 선택하기 때문에 인덱스를 통해 50% 밖에 걸러내지 못함.
            - 하지만 주민번호나 계좌번호 같은 경우엔 인덱스를 통해 데이터의 대부분을 걸러내기 때문에 빠르게 검색이 가능.

### 3-1. 여러 컬럼으로 인덱스 구성 시 기준.

- 여러 컬럼으로 인덱스 잡을 시 어떤 순서로 인덱스 구성?
    - 여러 컬럼으로 인덱스를 잡는다면 카디널리티가 높은순에서 낮은순으로 구성하는것이 성능상 이득.

### 3-2. 여러 컬럼으로 인덱스 시 조건 누락

- EX) 아래와 같이 인덱스가 잡혀있을 경우
- 인덱스: group_no, from_date, is_bonus
    - 여기서 가장 앞에 있는 group_no를 제외한 조회 쿼리를 사용 시 인덱스를 사용하지 못함.

~~~sql
explain
select *
from salaries
where from_date = '2002-07-30'
  and is_bonus

----
    결과
 - key 는 빠져있고.. Extra 는 using
where 을 타게 됨.
~~~

### 4. 인덱스 조회 시 주의사항.

- between, like, <, > 등 범위 조건은 해당 컬럼은 인덱스를 타지만, 그 뒤 인덱스 컬럼들은 인덱스가 사용되지 않음.
    - 즉, group_no, from_date, is_bonus 으로 인덱스가 잡혀있는데 조회쿼리를 where group_no=XX and is_bonus=YY and from_date > ZZ등으로 잡으면
      is_bonus는 인덱스가 사용되지 않음.
    - 범위조건으로 사용하면 안된다고 기억하면 좀 더 쉬움.
- 반대로 =, in 은 다음 컬럼도 인덱스를 사용.
    - in 은 결국 = 를 여러번 실행시킨 것.
    - 단 in 인자값으로 상수가 포함되면 문제없지만, 서브쿼리를 넣게되면 성능상 이슈가 발생.
    - in의 인자로 서브쿼리가 들어가면 서브쿼리의 외부가 먼저 실행되고, in 은 체크조건으로 실행되기 때문.
- AND 연산자는 각 조건들이 읽어와야 할 ROW 수를 줄이는 역할을 하지만, or 연산자는 비교해야할 ROW가 더 늘어나기 때문에 풀 테이블 스캔이 발생할 확률이 높음.
    - WHERE 에서 OR 를 사용할 때는 주의 필요.
- 인덱스로 사용된 컬럼값 그대로 사용해야만 인덱스가 사용.
    - 인덱스는 가공된 데이터를 저장하고 있지 않음.
        - where salary * 10 > 150000; 은 인덱스를 못타지만 where salary > 150000 / 10; 은 인덱스를 사용함.
        - 컬럼이 문자열인데 숫자로 조회하면 타입이 달라 인덱스가 사용되지 않음. 정확한 타입을 사용해야만 함.
- null 값의 경우 is null 조건으로 인덱스 레인지 스캔 가능.

### 5. 인덱스 컬럼 순서와 조회 컬럼 순서

- 최근엔 이전과 같이 꼭 인덱스 순서와 조회 순서를 지킬 필요는 없음.
- 인덱스 컬럼들이 조회조건에 포함되어 있는지가 중요.
- 옵티마이저가 조회 조건의 컬럼을 인덱스 컬럼 순서에 맞춰 재배열하는 과정이 추가되지만 거의 차이가 없음.

> 출처  : 
> - https://jojoldu.tistory.com/243
> -  https://umanking.github.io/2021/07/18/mysql-index/